#!/usr/bin/env flour

import lists;

let final NT = 5;

fn mkIntentArgs(rwList: list<string>) -> string {
    let args = <string>[];

    for rw in rwList.enumerate() {
        let j = 1 + rw.0;
        args <- "${rw.1}OnlyPartIntent<T${j}> pi${j}";
    }

    args.join(",\n")
}

fn mkChunkTask(rwList: list<string>) -> string {
    let args = <string>[];

    for rw in rwList.enumerate() {
        let j = 1 + rw.0;
        args <- "${rw.1}OnlyPartListView<T${j}>";
    }

    let n = rwList.len();
    let argsStr = args.join(",\n");

    "PartTask${n}<\n${argsStr},\nCompletableFuture<Void>> chunkTask"
}

fn mkListInits(n: int) -> string {
    ["final var list${i} = pi${i}.getUnderlying();" | i in [1..=n]].join("\n")
}

fn mkListsNotBusyInit(n: int) -> string {
    let args = ["list${i}.busy" | i in [1..=n]].join(", ");
    "final var listsNotBusy = Guard.newCondition(${args});"
}

fn mkViewInits(rwList: list<string>) -> string {
    (for rw in rwList.enumerate() {
        let j = rw.0 + 1;
        push ##
final var data${j} = list${j}.data;
final var dataSize${j} = data${j}.size();
final var lo${j} = partIndex(partNum, nChunks, dataSize${j}, nGhosts);
final var hi${j} = partIndex(partNum + 1, nChunks, dataSize${j}, nGhosts);
final var chunkSize${j} = hi${j} - lo${j};
final var view${j} = new ${rw.1}OnlyPartListView<>(data${j}, lo${j}, chunkSize${j}, nGhosts, partNum);
        ##;
    }).join("\n\n")
}

fn mkBusyFalseSetters(rwList: list<string>) -> string {
    (for rw in rwList.enumerate() {
        let j = rw.0 + 1;
        push ##
Guard.runGuarded(list${j}.busy, busy${j}_ -> {
    busy${j}_.set(false);
    list${j}.notBusy.signalAll();
});
        ##;
    }).join("\n\n")
}

fn mkNotBusySignalers(rwList: list<string>) -> string {
    (for rw in rwList.enumerate() {
        let j = rw.0 + 1;
        push ##
Guard.runCondition(list${j}.notBusy, busy${j} -> {
    listsNotBusy.signal();
    return begun.get();
});
        ##;
    }).join("\n\n")
}

fn mkRunCondition(rwList: list<string>) -> string {
    let busyList = ["busy${i}" | i in [1..=rwList.len()]];
    let busyGetlist = ["${b}.get()" | b in busyList].join(" || ");
    let busySetList = ["${b}.set(true);" | b in busyList].join("\n");
    let viewList = ["view${i}" | i in [1..=rwList.len()]].join(", ");

    return ##

Guard.runCondition(listsNotBusy, (${busyList.join(", ")}) -> {
    if (${busyGetlist}) {
        return false;
    }

    ${busySetList}

    begun.set(true);

    for (int partNum = 0; partNum < nChunks - 1; partNum++) {
        ${mkViewInits(rwList)}

        Pool.run(() -> {
            chunkTask.apply(${viewList}).thenRun(tasksDone::signal);
        });
    }

    final var partNum = nChunks - 1;

    ${mkViewInits(rwList)}

    chunkTask.apply(${viewList}).thenRun(tasksDone::signal);

    tasksDone.getFut().thenRun(() -> {
        done.complete(null);

        ${mkBusyFalseSetters(rwList)}
    });

    return true;
});

    ##.trim();
}

fn mkBody(rwList: list<string>) -> string {
    ##

final var done = new CompletableFuture<Void>();
final var tasksDone = new CountdownLatch(nChunks);

${mkListInits(rwList.len())}

${mkListsNotBusyInit(rwList.len())}

final var begun = new AtomicBoolean();

${mkRunCondition(rwList)}

if (!begun.get()) {
    ${mkNotBusySignalers(rwList)}
}

return done;

    ##.trim()
}

fn emitRunParted(tpList: list<string>, rwList: list<string>) {
    let piList = ["pi${i}" | i in [1..=rwList.len()]].join(", ");

    println(
        ##

public static <${tpList.join(', ')}> CompletableFuture<Void> runPartitioned(
    int nChunks,
    ${mkIntentArgs(rwList)},
    ${mkChunkTask(rwList)}
) {
    return runPartitioned(nChunks, 0, ${piList}, chunkTask);
}

        ##.trimMulti()
    );

    println(
        ##

public static <${tpList.join(', ')}> CompletableFuture<Void> runPartitioned(
    int nChunks, int nGhosts,
    ${mkIntentArgs(rwList)},
    ${mkChunkTask(rwList)}
) {
    ${mkBody(rwList)}
}

        ##.trimMulti()
    );
    println("");
}

fn main() {
    println("// region Generated by Generate_runPartitioned.mj");

    let typeParams = <string>[];

    for i in [1..=NT] {
        typeParams <- "T${i}";
        for j in [0..=i] {
            let rwList = ["Read"] * j + ["Write"] * (i - j);
            for p in rwList.permutations().uniqueElements() {
                emitRunParted(typeParams, p);
            }
        }
    }

    println("// endregion");
}

main();
