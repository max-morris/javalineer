import java.security.MessageDigest

plugins {
    id 'java'
    id 'java-library'
    id 'maven-publish'
    id 'idea'
}

group = 'edu.lsu.cct.javalineer'

repositories {

}

sourceSets {
    main {
        java {
            // Include generated sources directory
            srcDir "$buildDir/generated/sources/javalineer/main/java"
            // Exclusions for originals are added later based on codegenEntries
        }
    }
    tests {
        java {
            srcDir 'src/tests/java'
        }
    }
}

java {
    withSourcesJar()
}

// Generic code generation splice machinery
// Configure codegen entries here: each is [name, targetFile, generatorScript, marker]
ext.codegenEntries = [
    [
        name: 'generatePartitionableListOverloads',
        target: 'src/main/java/edu/lsu/cct/javalineer/PartitionableList.java',
        generator: 'scripts/Generate_runPartitioned.mj',
        marker: '/* CODEGEN: generatePartitionableListOverloads */'
    ]
]

def genSrcDir = file("$buildDir/generated/sources/javalineer/main/java")

// Exclude original target files so the spliced versions are the ones compiled
sourceSets.main.java {
    codegenEntries.each { cfg ->
        exclude { details ->
            def ap = details.file.absolutePath.replace('\\','/')
            def targetAbs = file(cfg.target).absolutePath.replace('\\','/')
            ap == targetAbs
        }
    }
}

// Helper to compute output file under generated dir, mirroring package
static File codegenOutputFor(Project project, File genSrcDir, File targetFile) {
    def srcMainJava = new File(project.projectDir, 'src/main/java').absolutePath.replace('\\','/')
    def targetAbs = targetFile.absolutePath.replace('\\','/')
    if (!targetAbs.startsWith(srcMainJava)) {
        throw new GradleException("Target must be under src/main/java: ${targetFile}")
    }
    def rel = targetAbs.substring(srcMainJava.length() + 1)
    return new File(genSrcDir, rel)
}

// Register a task per entry
codegenEntries.each { cfg ->
    def targetFile = file(cfg.target)
    def generatorFile = file(cfg.generator)
    def outFile = codegenOutputFor(project, genSrcDir, targetFile)

    // Flour interpreter configuration and caching
    def flourUrl = 'https://www.cct.lsu.edu/~mmorris/flour/bin/2025-09-18/flouri.jar'
    def flourMd5 = 'fd46dbc4118ee70f7406f46ad7d28ad8'

    // Return a File pointing to cached flour jar, downloading it once if missing and verifying checksum
    Closure<File> getFlourJar = {
        // Cache under Gradle user home so it persists across builds and clean tasks
        File cacheDir = new File(gradle.gradleUserHomeDir, 'javalineer/flour')
        cacheDir.mkdirs()
        String fileName = URLEncoder.encode(flourUrl, 'UTF-8')
        File jarFile = new File(cacheDir, fileName)

        // Helper to compute MD5 digest of a file
        Closure<String> computeMd5 = { File f ->
            def md = MessageDigest.getInstance('MD5')
            f.withInputStream { is ->
                byte[] buf = new byte[8192]
                int r
                while ((r = is.read(buf)) != -1) {
                    md.update(buf, 0, r)
                }
            }
            byte[] digest = md.digest()
            StringBuilder sb = new StringBuilder()
            for (byte b : digest) {
                sb.append(String.format("%02x", b))
            }
            sb.toString()
        }

        // Helper to download the jar
        Closure<Void> download = {
            try {
                new URL(flourUrl).withInputStream { is ->
                    jarFile.withOutputStream { os -> os << is }
                }
            } catch (Exception e) {
                throw new GradleException("Failed to download flour interpreter from ${flourUrl}: " + e.message)
            }
            return null
        }

        if (!jarFile.exists()) {
            download.call()
        } else {
            // Verify existing cached file; if mismatch, re-download
            String md5 = computeMd5.call(jarFile)
            if (!md5.equalsIgnoreCase(flourMd5)) {
                jarFile.delete()
                download.call()
            }
        }

        // Verify after ensuring presence
        String finalMd5 = computeMd5.call(jarFile)
        if (!finalMd5.equalsIgnoreCase(flourMd5)) {
            jarFile.delete()
            throw new GradleException("Checksum verification failed for flour interpreter. Expected ${flourMd5}, got ${finalMd5}")
        }

        return jarFile
    }

    tasks.register(cfg.name as String) {
        group = 'code generation'
        description = "Generates spliced ${outFile.name} by inserting code from ${generatorFile.name} at marker"

        inputs.file(targetFile)
        inputs.file(generatorFile)
        // Re-run if the interpreter URL or checksum changes
        inputs.property('flourUrl', flourUrl)
        inputs.property('flourMd5', flourMd5)
        outputs.file(outFile)

        doLast {
            outFile.parentFile.mkdirs()
            def sourceText = targetFile.getText('UTF-8')
            def marker = cfg.marker as String
            if (!sourceText.contains(marker)) {
                throw new GradleException("Marker not found in ${targetFile}: ${marker}")
            }
            String generatedBlock
            try {
                def baos = new ByteArrayOutputStream()
                File flourJar = getFlourJar.call()
                exec {
                    commandLine 'java', '-jar', flourJar.absolutePath, generatorFile.absolutePath
                    standardOutput = baos
                }
                generatedBlock = baos.toString('UTF-8')
            } catch (Exception e) {
                throw new GradleException("${generatorFile.name} failed: (" + e.class.simpleName + "): " + e.message)
            }
            def newText = sourceText.replace(marker, generatedBlock)
            outFile.setText(newText, 'UTF-8')
        }
    }
}

// Make IDE aware this is a generated source directory
idea {
    module {
        generatedSourceDirs += genSrcDir
    }
}

// Ensure compilation uses the generated files when present
tasks.named('compileJava') {
    dependsOn codegenEntries.collect { cfg -> tasks.named(cfg.name as String) }
}

publishing {
    publications {
        maven(MavenPublication) {
            from components.java
            version System.getenv("GITHUB_REFNAME") + "-" + System.getenv("GITHUB_HASH")
        }
    }

    repositories {
        maven {
            name = "GitHubPackages"
            url = "https://maven.pkg.github.com/" + System.getenv("GITHUB_REPOSITORY")
            credentials {
                username = System.getenv("GITHUB_ACTOR")
                password = System.getenv("GITHUB_TOKEN")
            }
        }
    }
}

dependencies {
    testsImplementation sourceSets.main.output
}
